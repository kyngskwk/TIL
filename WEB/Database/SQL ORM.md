# :card_index_dividers: SQL ORM

<img width="766" alt="_2020-09-05__10 06 34" src="https://user-images.githubusercontent.com/60081217/92622640-3c926c80-f300-11ea-8d8d-c235b2c5ccbe.png">

### 1. ORM 이란

데이터베이스의 객체 지향 프로그래밍 언어 (Python, node JS 등)간의 호환되지 않는 데이터를 변환, 매핑하는 프로그래밍 기법이다. **객체(클래스)**와 **관계(관계형 데이터 베이스)**와의 설정을 의미한다.

객체 지향 프로그래밍언어 (OOP, Object Programming)에서 RDBMS를 연동할 때, 클라이언트 라이브러리/SQL을 사용하여 구현할 수 있다. 하지만 ORM을 사용하면, 좀 더 높은 생산성(빠른 개발속도, 짧은 개발기간)으로 개발할 수 있다.

객체 모델과 관계형 모델간의 불일치가 존재하는데 이 객체간의 관계를 바탕으로  SQL을 자동 생성하여 불일치를 해결하는 것이 ORM이다.

→ python과 sql사이의 통역하는 것! → 장고가 위의  orm을 sql로 변역하는 것



### 2. ORM 장정

- **객체 지향적 코드로 인해 더 직관적이고 비즈니스 로직에 집중할 수 있도록 도와준다.**
  - CRUD을 위한 긴 SQL 문장을 작성할 필요가 없다. (여전히 쿼리작성은 필요하지만)
  - 각 객체(Model)별로 코드를 작성하여 가독성을 높여 준다.
  - SQL의 절차적 접근이 아닌 객체적인 접근으로 생산성을 높여 준다.
- **재사용 및 유지보수의 편리성이 증가한다.**
  - 매핑 정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.
  - ORM은 독립적으로 작성이 되어 있고 해당 객체들은 재사용이 가능 하다.
- **DBMS에 대한 종속성이 줄어든다.(\*종속성: 프로그램 구조가 데이터 구조에 영향을 받는 것을 의미함.)**
  - 대부분의 ORM은 DB에 종속적이지 않다.
  - 개발자는 Object에 집중함으로 DBMS를 교체하는 극단적인 작업에도 비교적 적은 리스크와 시간이 소요된다.
  - 종속적이지 않다는 것은 구현 방법 뿐만 아니라 많은 솔루션에서 자료형 타입까지 유효하다.

### 3. ORM 단점

- 완벽한 ORM만으로는 구현하기가 어렵다.
  - 사용하기에는 편하지만 설계에는 매우 신중해야 한다.
  - 프로젝트의 복잡성이 높아질 경우 난이도 또한 올라갈 수 있다.
  - 잘못 구현된 경우 속도 저하 및 심한 경우 일관성이 무너지는 문제점이 생길 수 있다.
- 프로시저가 많은 시스템에서는 ORM의 객체 지향적인 장점을 활용하기 어렵다.
  - 이미 프로시저가 많은 시스템에서는 다시 객체로 바꿔하 하며, 그 과정에서 생산성 저하 혹은 리스크가 발생할 수 있다.

**(\*프로시저: 특정작업을 위한 프로그램의 일부. 함수와 같은 의미)**
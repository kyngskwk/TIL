# 단순 연결 리스트(linked list)

### 리스트

- 순서를 가진 데이터의 집합을 가리키는 추상 자료형(abstract data type)
- 동일한 데이터를 가지고 있어ㄴ도 상관없다
- 구현 방법에 따라 크게 두가지로 나뉨
  1. 순차 리스트 : 배열을 기반으로 구현된 리스트
  2. 연결 리스트 : 메모리의 동적할당을 기반으로 구현된 리스트



### 순차 리스트

- 연속적인 메모리 공간에 저장하는 것
- 1차원 배열에 항목들을 순서대로 저장한다.
- 데이터의 종류와 구조에 따라 구조화된 자료구조를 만들어 배열로 만들 수도 있다.
- 데이터 접근은 배열의 인덱스를 이용해 원하는 위치의 데이터에 접근할 수 있다.
- 삽입 연산
  - 삽입 위치 다음의 항목들을 이동해야 한다.
- 삭제 연산
  - 삭제 위치 다음의 항목들을 이동해야 한다.

⇒ 단순 배열의 이용해 순차리스트를 구현해 사용하는 경우, 자료의 삽입/삭제의 경우 원소들의 이동이 일어나기 때문에 추가적인 작업이 필요함

⇒ 배열의 크기가 정해져 있는 경우, 실제로 사용될 메모리보다 크게 할당하여 메모리 낭비를 초래할 수 있음. 몇 개의 자료가 필요한지 미리 정해놓고 써야함 → python을 경우에는 append를 쓰기 때문에 저장하지 않아도 되지만, 보통의 경우에는 미리 정해놓고 시작한다.



### 연결 리스트(linked list)

- 자료의 논리적인 순서와 메모리 상의 물리적 순서가 일치하지 않음 → 인덱스로 바로 접근할 수 없다는 말임
- 그 다음의 원소가 무엇인지에 관한 정보만 있다고 생각하면 됨!
- 자료구조의 크기를 동적으로 조정할 수 있어 메모리의 효율적인 사용이 가능하다.



### 노드

- 연결 리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료단위
- 구성요소
  1. 데이터 필드 : 원소의 값을 저장하는 자료구조, 저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용함
  2. 링크 필드 : 다음 노드의 주소를 저장하는 자료구조

```python
a = 100
b = 100

print(id(a), id(b))
>> 두개의 아이디가 동일하게 나온다.
>> 값이 저장되어 있고 그 값을 정하는 


arr = [0]*5
for i in range(5):
	print(id(arr[i]))
>> id가 모두 동일하게 나옴
>> 0이라는 값이 하나 정해지면 다 같은 0을 가리키고 있는 것
```



### 노드

- 연결 리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료단위
- 구성요소
  1. 데이터 필드 : 원소의 값을 저장하는 자료구조, 저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용함
  2. 링크 필드 : 다음 노드의 주소를 저장하는 자료구조



- 단순 연결리스트의 삽입 연산 과정

<img width="838" alt="_2020-09-02__1 19 21" src="https://user-images.githubusercontent.com/60081217/91956123-26ecd800-ed3f-11ea-8c41-315156065e1e.png">

- 단순 연결 리스트의 삭제 연산 과정 

![del](https://user-images.githubusercontent.com/60081217/91956333-7d5a1680-ed3f-11ea-92d5-ad4dadcb8e76.png)





### 단일(단순) 연결 리스트

```python
class Node:
	def __init__(self, d=0, n=None):
		self.data = d
		self.next = None
		print(d, '생성')
	
	def __del__(self):
		print(self.data, '삭제')

class LinkedList:
	def __init__(self):
		self.head = None  # 첫 번째 노드
		self.size = 0     # 노드의 수

mylist = LinkedList()

def printList(lst): # lst: LinkedList 객체
	cur = lst.head

	while cur is not None:
		print(cur.data)
		cur = cur.next

n5 = Node(5); n4 = Node(4, n5); n3 = Node(3, n4)
n2 = Node(2, n3); n1 = Node(1, n2)
mylist.head = n1;
mylist.size = 5
```


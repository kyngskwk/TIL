# 최소 신장 트리(MST)

- 그래프에서 최소 비용 문제
1. 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리 (MST)
  2. 두 정점 사이의 최소 비용의 경로 찾기 → 최단 거리(가중치 X : BFS 로 푼다)
- MST:Minimum Spanning Tree - 프림 알고리즘, 크루스 칼
- 신장 트리 : n개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소 신장 트리 : 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치 합이 최소인 신장 트리
- MST 표현 방법(1) → 그래프 표현

<img width="849" alt="MST1" src="https://user-images.githubusercontent.com/60081217/85917913-32cca180-b899-11ea-9273-42e4a6a9cfc2.png">



- 그래프를 → 인접 행렬, 인접 리스트로 표현
- MST 표현 (2) → 알짜배기만 남긴 그래프

<img width="975" alt="MST2" src="https://user-images.githubusercontent.com/60081217/85917914-34966500-b899-11ea-816c-02dd06379330.png">

- 시작점, 끝점, 가중치 → 인접 리스트
- 부모, 현정점
- Prim 알고리즘 → 정점 (크루스칼 → 간선)

  - 하나의 정점에 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식
    1. 임의 정점을 하나 선택해서 시작
    2. 선택한 정점과 인점하는 정점들 중의 **최소 비용의 간선이 존재하는 정점**을 선택
    3. 모든 정점이 선택될 때 까지 위의 두가지 과정을 반복

<img width="776" alt="algo" src="https://user-images.githubusercontent.com/60081217/85917916-36602880-b899-11ea-9891-d1e7fe9d6a05.png">







## 예제

<img width="396" alt="q" src="https://user-images.githubusercontent.com/60081217/85918182-5690e700-b89b-11ea-8e2f-7af382e834bf.png">



- 파이(부모) 와 key(가중치) 정보를 이용해서 인접 정점의 가중치를 저장해 나가면서 해결한다.
- 파이와 key를 먼저 초기화 시킴 ( 무한대, None/-1)
- 시작 정점 → key(시작점) = 0으로 셋팅
- **아직 MST가 아니면서 key가 최소인 정점**
- **u를 MST로 선택**
- **u에 인접하고, 아직 MST가 아닌 정점 : w 라고 하면 → key[w]를 보고 u → w 갈 수 있는 가중치를 본다. → 두 개 비교 해서 작으면 갱신.**
- 위의 주황색 과정을 계속 반복한다.



- 시작

| 정점번호 | 0 : 시작 | 1      | 2      | 3       | 4       | 5       | 6       |
| -------- | -------- | ------ | ------ | ------- | ------- | ------- | ------- |
| 파이     | -1       | -1     | -1     | -1      | -1      | -1      | -1      |
| key      | 0        | 999999 | 999999 | 9999999 | 9999999 | 9999999 | 9999999 |

- 2번 선택 과정 -> 2번이 최소니까

| 정점번호 | 0 : 시작 | 1    | 2: 0 -> 2 | 3       | 4       | 5    | 6    |
| -------- | -------- | ---- | --------- | ------- | ------- | ---- | ---- |
| 파이     | -1       | 0    | -0        | -1      | -1      | 0    | 0    |
| key      | 0        | 32   | 31        | 9999999 | 9999999 | 60   | 51   |

- 2번 정점에서 출발할 때에 대한 갱신 끝 -> 최소점 1번 선택

| 정점번호 | 0 : 시작 | 1: 2 -> 1 | 2: 0 -> 2 | 3       | 4    | 5    | 6    |
| -------- | -------- | --------- | --------- | ------- | ---- | ---- | ---- |
| 파이     | -1       | 2         | 0         | -1      | 2    | 0    | 2    |
| key      | 0        | 21        | 31        | 9999999 | 46   | 60   | 25   |

- 1번 정점에서 갈 수 있는 점 없음, 갱신 놉 -> 다른 최소 점 6번 선택

| 정점번호 | 0 : 시작 | 1: 2 -> 1 | 2: 0 -> 2 | 3       | 4 : 2-> 4 | 5    | 6: 2 -> 6 |
| -------- | -------- | --------- | --------- | ------- | --------- | ---- | --------- |
| 파이     | -1       | 2         | 0         | -1      | 2         | 0    | 2         |
| key      | 0        | 21        | 31        | 9999999 | 46        | 60   | 25        |

- 4번에서 갈 수 있는 점들 갱신 -> 최소 점 3번 선택

| 정점번호 | 0 : 시작 | 1: 2 -> 1 | 2: 0 -> 2 | 3: 4 -> 3 | 4 : 2-> 4 | 5    | 6: 2 -> 6 |
| -------- | -------- | --------- | --------- | --------- | --------- | ---- | --------- |
| 파이     | -1       | 2         | 0         | 4         | 2         | 0    | 2         |
| key      | 0        | 21        | 31        | 34        | 46        | 60   | 25        |

- 3번에서 갈 수 있는 점 갱신 -> 5번 선택

| 정점번호 | 0 : 시작 | 1: 2 -> 1 | 2: 0 -> 2 | 3 : 4 -> 3 | 4 : 2-> 4 | 5    | 6: 2 -> 6 |
| -------- | -------- | --------- | --------- | ---------- | --------- | ---- | --------- |
| 파이     | -1       | 2         | 0         | 4          | 2         | 0    | 2         |
| key      | 0        | 21        | 31        | 34         | 46        | 60   | 25        |





### 코드로 구현

```python
# 간선 가중치 값이 0인 간선은 없다 가정!
V, E = map(int, input().split())
adj = [[0] * V for _ in range(V)] # 인접 행렬
for i in range(E): # for문을 간섭 만큼 돈다.
    s, e, c = map(int, input().split()) # 시작 정점, 끝 정점, 가중치
    adj[s][e], adj[e][s] = c, c # 무방향

# key, p, mst 준비
INF = float('inf') # 큰 값으로 초기화
key = [INF] * V
p = [-1] * V
mst = [False] * V # 아직 안갔다.

# 시작점 선택: 0번 선택
key[0] = 0
cnt = 0
result = 0
while cnt < V: # 반복해야 하는 작업
    # 아직 mst가 아니고 key가 최소인 정점 선택 : u신
    min = INF # min값을 최소값으로 계속 갱신시키면 된다.
    u = -1
    for i  in range(V):
        if not mst[i] and key[i] < min: # 아직 도달 안했고, key값이 최소값 보다 작으면
            min = key[i] # min값은 key값이 된다.
    # u를 mst로 선택
    mst[u] = True
    result += min
    cnt += 1

    # key 값을 갱신
    # u에 인접하고 아직 mst가 아닌 정점 w에서 key[w] > u-w 가중치면 갱신
    for w in range(V):
        if adj[u][w] > 0 and not mst[w] and key[w] > adj[u][w]:
            key[w] = adj[u][w] # 찾아갈 곳의 가중치로 바꿔줌
            p[w] = u # 부모 정점도 바꿔준다.
```



### 수도 코드

```python
MST_PRIM(G, r) # 그래프 정보, 인접 행렬/리스트, r: 시작 정점
	for u in G.V: # 모든 정점에 대하여
		u.key <- 무한대
		u.파이 <- NULL or -1 # 부모와, 가중치값 일단 초기화!

	r.key <- 0 # 시작점의 key : 0으로 둔다
	Q <- G.V # 우선 순위 Q에 모든 정점 넣는다, 이거 시간 복잡도 때문에 쓴다.

	while Q != 0: # 큐가 비어질 때 까지 반복한다 
		u <- Extract_Min(Q) #  key값이 가장 작은 정점 가져오기
		for V in G.Adj[u] # u의 인접 정점들
			if v in Q and w(u, v) < v.key # Q에 없으면 MST가 아니라는 말, 현재의 key값과, 가중치값 비교
				v.파이 <- u # 부모값 갱신
				v.key <- w(u, v) # key값 갬신
				# 여기에 큐값 갱신 코드가 있다.
```

- 우선 순위 큐 → 우선 순위에 따라 .pop()을 할 수 있다는 말 : 이건 이진힙으로 구현 가능함 (나중에)



### 수도 코드를 진짜 코드로 구현

```python
V, E = map(int, input().split())
adj = {i: [] for i in range(V)}
# {0 : [[5, 60], [1, 32], [2, 31], [6, 51]], 1: [], 2: [],.... } 이런 식으로 저장되게 된다.
for i in range(E): # for문을 간섭 만큼 돈다.
    s, e, c = map(int, input().split()) # 시작 정점, 끝 정점, 가중치
    adj[s][e], adj[e][s] = c, c # 무방향
# print(adj)
# key, mst, 우선순위 큐 준비

INF = float('inf')
key = [INF] * V
mst = [False] * V
pq = []
# 시작 정점 선택 : 0
key[0] = 0
# 큐에 시작 정점을 넣음 -> (key, 정점인덱스)
# 우선순위 큐 -> 이진힙 -> heapq 라이브러리 사용(import)
heapq.heappush(pq, (0, 0)) # heap의 구조를 유지하면서 하나의 원소를 집어 넣는다.
# 우선순위 큐 -> 원소의 첫번째 요소(튜플의)가 기준 -> key를 우선순위로 가져오겠다
# 시작정점만 넣은 상태
result = 0

while pq:
    # 최소값 찾기
    k, node = heapq.heappop(pq) # 내가 가지고 있던 heap에서 가장 작은 값, 맨 앞에 값 가져온다.
    # mst로 선택하기
    mst[node] = True
    result += k
    # key 갱신 -> key 배열 / 큐
    # adj[node] == key값의 인접 정점과 가중치의 리스트를 받게 된다.
    # for 문을 돌면 내가 가진 인접 행렬만큼 돈다.
     for dest, wt in adj[node]:
         if not mst[dest] and key[dest] > wt:
             key[dest] = wt
             # 큐 개신 -> 새로운 (key, 정점) 삽입 -> 필요없는 원소 스 (원래 있던거 수정하는 것 대신)킵
             heapq.heappush(pq, (key[dest], dest))

print(result)
```